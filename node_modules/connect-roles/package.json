{
  "name": "connect-roles",
  "description": "Provides dynamic roles based authorization for node.js connect and express servers.",
  "version": "3.0.2",
  "homepage": "http://documentup.com/ForbesLindesay/connect-roles",
  "repository": {
    "type": "git",
    "url": "git://github.com/ForbesLindesay/connect-roles.git"
  },
  "main": "./index",
  "devDependencies": {
    "mocha": "*"
  },
  "scripts": {
    "test": "mocha -R spec"
  },
  "author": {
    "name": "Forbes Lindesay"
  },
  "license": "BSD",
  "keywords": [
    "roles",
    "authorization",
    "authentication",
    "security",
    "connect",
    "express",
    "passport",
    "everyauth"
  ],
  "dependencies": {
    "path-to-regexp": "0.0.2",
    "ert": "1.0.1",
    "promise": "~4.0.0"
  },
  "readme": "# Connect Roles\n<img src=\"http://i.imgur.com/opZKqAi.png\" align=\"right\"/>\n\nConnect roles is designed to work with connect or express.  It is an authorisation provider, not an authentication provider.  It is designed to support context sensitive roles/abilities, through the use of middleware style authorisation strategies.\n\nIf you're looking for an authentication system I suggest you check out [passport.js](https://github.com/jaredhanson/passport), which works perfectly with this module.\n\n[![Build Status](https://secure.travis-ci.org/ForbesLindesay/connect-roles.png?branch=master)](http://travis-ci.org/ForbesLindesay/connect-roles)\n[![Dependency Status](https://gemnasium.com/ForbesLindesay/connect-roles.png)](https://gemnasium.com/ForbesLindesay/connect-roles)\n[![NPM version](https://badge.fury.io/js/connect-roles.png)](http://badge.fury.io/js/connect-roles)\n\n## Installation\n\n    $ npm install connect-roles\n\n## Usage\n\n```javascript\nvar authentication = require('your-authentication-module-here');\nvar ConnectRoles = require('connect-roles');\nvar express = require('express');\nvar app = express();\n\nvar user = new ConnectRoles({\n  failureHandler: function (req, res, action) {\n    // optional function to customise code that runs when\n    // user fails authorisation\n    var accept = req.headers.accept || '';\n    res.status(403);\n    if (~accept.indexOf('html')) {\n      res.render('access-denied', {action: action});\n    } else {\n      res.send('Access Denied - You don\\'t have permission to: ' + action);\n    }\n  }\n});\n\napp.use(authentication)\napp.use(user.middleware());\n\n//anonymous users can only access the home page\n//returning false stops any more rules from being\n//considered\nuser.use(function (req, action) {\n  if (!req.isAuthenticated()) return action === 'access home page';\n})\n\n//moderator users can access private page, but\n//they might not be the only ones so we don't return\n//false if the user isn't a moderator\nuser.use('access private page', function (req) {\n  if (req.user.role === 'moderator') {\n    return true;\n  }\n})\n\n//admin users can access all pages\nuser.use(function (req) {\n  if (req.user.role === 'admin') {\n    return true;\n  }\n});\n\n\napp.get('/', user.can('access home page'), function (req, res) {\n  res.render('private');\n});\napp.get('/private', user.can('access private page'), function (req, res) {\n  res.render('private');\n});\napp.get('/admin', user.can('access admin page'), function (req, res) {\n  res.render('admin');\n});\n\napp.listen(3000);\n```\n\n## API\n\nTo access all methods, you must construct an instance via:\n\n```js\nvar ConnectRoles = require('connect-roles');\nvar roles = new ConnectRoles(options);\n```\n\n### roles.use(fn(req, action))\n\nDefine and authorisation strategy which takes the current request and the action being performed.  fn may return `true`, `false` or `undefined`/`null`\n\nIf `true` is returned then no further strategies are considred, and the user is **granted** access.\n\nIf `false` is returned, no further strategies are considered, and the user is **denied** access.\n\nIf `null`/`undefined` is returned, the next strategy is considerd.  If it is the last strategy then access is **denied**.\n\n### roles.use(action, fn(req))\n\nThe strategy `fn` is only used when the action is equal to `action`.  It has the same behaviour with regards to return values as `roles.use(fn(req, action))` (see above).\n\nIt is equivallent to calling:\n\n```javascript\nroles.use(function (req, act) {\n  if (act === action) {\n    return fn(req);\n  }\n});\n```\n\n**N.B.** The action must not start with a `/` character\n\n### roles.use(action, path, fn(req))\n\nPath must be an express style route.  It will then attach any parameters to `req.params`.\n\ne.g.\n\n```javascript\nroles.use('edit user', '/user/:userID', function (req) {\n  if (req.params.userID === req.user.id) return true;\n});\n```\n\nNote that this authorisation strategy will only be used on routes that match `path`.\n\nIt is equivallent to calling:\n\n```javascript\nvar keys = [];\nvar exp = pathToRegexp(path, key);\nroles.use(function (req, act) {\n  var match;\n  if (act === action && match = exp.exec(req.path)) {\n    req = Object.create(req);\n    req.params = Object.create(req.params || {});\n    keys.forEach(function (key, i) {\n      req.params[key.name] = match[i + 1];\n    });\n    return fn(req);\n  }\n});\n```\n\n### roles.can(action) and roles.is(action)\n\n`can` and `is` are synonyms everywhere they appear.\n\nYou can use these as express route middleware:\n\n```javascript\nvar user = roles;\n\napp.get('/profile/:id', user.can('edit profile'), function (req, res) {\n  req.render('profile-edit', { id: req.params.id });\n})\napp.get('/admin', user.is('admin'), function (req, res) {\n  res.render('admin');\n}\n```\n\nIf you want to skip only the current routes, you can also use `.here`\n\n```js\napp.get('/', user.can('see admin page').here, function (req, res, next) {\n  res.render('admin-home-page');\n});\napp.get('/', function (req, res, next) {\n  res.render('default-home-page');\n});\n```\n\n### req.userCan(action) and req.userIs(action)\n\n`can` and `is` are synonyms everywhere they appear.\n\nThese functions return `true` or `false` depending on whether the user has access.\n\ne.g.\n\n```javascript\napp.get('/', function (req, res) {\n  if (req.user.is('admin')) {\n    res.render('home/admin');\n  } else if (user.can('login')) {\n    res.render('home/login');\n  } else {\n    res.render('home');\n  }\n})\n```\n\n### user.can(action) and user.is(action)\n\nInside the views of an express application you may use `userCan` and `userIs` which are equivallent to `req.userCan` and `req.userIs`\n\ne.g.\n\n```html\n<% if (userCan('impersonate')) { %>\n  <button id=\"impersonate\">Impersonate</button>\n<% } %>\n```\n\nor in jade:\n\n```jade\nif userCan('impersonate')\n  button#impersonate Impersonate\n```\n\n**N.B.** not displaying a button doesn't mean someone can't do the thing that the button would do if clicked.  The view is not where your security should go, but it is important for useability that you don't display buttons that will just result in 'access denied'.\n\n## License\n\nMIT\n\nIf you find it useful, a payment via [gittip](https://www.gittip.com/ForbesLindesay) would be appreciated.\n",
  "readmeFilename": "readme.md",
  "bugs": {
    "url": "https://github.com/ForbesLindesay/connect-roles/issues"
  },
  "_id": "connect-roles@3.0.2",
  "dist": {
    "shasum": "4c0edcd413ec07eda3c8d28acf2595e952145a70"
  },
  "_from": "connect-roles@",
  "_resolved": "https://registry.npmjs.org/connect-roles/-/connect-roles-3.0.2.tgz"
}
